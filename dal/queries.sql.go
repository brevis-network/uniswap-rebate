// Code generated by sqlc. DO NOT EDIT.
// source: queries.sql

package dal

import (
	"context"

	"github.com/brevis-network/uniswap-rebate/binding"
	"github.com/brevis-network/uniswap-rebate/webapi"
)

const monGet = `-- name: MonGet :one
SELECT key, blknum, blkidx FROM monitor WHERE key = $1
`

func (q *Queries) MonGet(ctx context.Context, key string) (Monitor, error) {
	row := q.db.QueryRowContext(ctx, monGet, key)
	var i Monitor
	err := row.Scan(&i.Key, &i.Blknum, &i.Blkidx)
	return i, err
}

const monSet = `-- name: MonSet :exec
INSERT INTO monitor (key, blknum, blkidx) VALUES ($1, $2, $3) ON CONFLICT (key) DO UPDATE
SET blknum = excluded.blknum, blkidx = excluded.blkidx
`

type MonSetParams struct {
	Key    string `json:"key"`
	Blknum uint64 `json:"blknum"`
	Blkidx int64  `json:"blkidx"`
}

func (q *Queries) MonSet(ctx context.Context, arg MonSetParams) error {
	_, err := q.db.ExecContext(ctx, monSet, arg.Key, arg.Blknum, arg.Blkidx)
	return err
}

const poolAdd = `-- name: PoolAdd :exec
INSERT INTO pools (poolid, poolkey) VALUES ($1, $2)
`

type PoolAddParams struct {
	Poolid  string          `json:"poolid"`
	Poolkey binding.PoolKey `json:"poolkey"`
}

func (q *Queries) PoolAdd(ctx context.Context, arg PoolAddParams) error {
	_, err := q.db.ExecContext(ctx, poolAdd, arg.Poolid, arg.Poolkey)
	return err
}

const poolGet = `-- name: PoolGet :one
SELECT poolkey FROM pools WHERE poolid = $1
`

func (q *Queries) PoolGet(ctx context.Context, poolid string) (binding.PoolKey, error) {
	row := q.db.QueryRowContext(ctx, poolGet, poolid)
	var poolkey binding.PoolKey
	err := row.Scan(&poolkey)
	return poolkey, err
}

const poolIds = `-- name: PoolIds :many
SELECT poolid FROM pools
`

func (q *Queries) PoolIds(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, poolIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var poolid string
		if err := rows.Scan(&poolid); err != nil {
			return nil, err
		}
		items = append(items, poolid)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reqAdd = `-- name: ReqAdd :exec
INSERT INTO reqs (id, proofreq) VALUES ($1, $2)
`

type ReqAddParams struct {
	ID       int64               `json:"id"`
	Proofreq *webapi.NewProofReq `json:"proofreq"`
}

func (q *Queries) ReqAdd(ctx context.Context, arg ReqAddParams) error {
	_, err := q.db.ExecContext(ctx, reqAdd, arg.ID, arg.Proofreq)
	return err
}

const reqGet = `-- name: ReqGet :one
SELECT id, step, proofreq, calldata FROM reqs WHERE id = $1
`

func (q *Queries) ReqGet(ctx context.Context, id int64) (Req, error) {
	row := q.db.QueryRowContext(ctx, reqGet, id)
	var i Req
	err := row.Scan(
		&i.ID,
		&i.Step,
		&i.Proofreq,
		&i.Calldata,
	)
	return i, err
}
