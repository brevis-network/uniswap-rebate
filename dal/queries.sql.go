// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package dal

import (
	"context"

	"github.com/brevis-network/brevis-sdk/sdk/proto/commonproto"
	"github.com/brevis-network/brevis-sdk/sdk/proto/gwproto"
	"github.com/brevis-network/uniswap-rebate/binding"
	"github.com/brevis-network/uniswap-rebate/webapi"
)

const claimerAdd = `-- name: ClaimerAdd :exec
INSERT INTO claimer (chid, router, evlog) VALUES ($1, $2, $3)
`

type ClaimerAddParams struct {
	Chid   uint64                   `json:"chid"`
	Router string                   `json:"router"`
	Evlog  binding.ClaimHelpClaimer `json:"evlog"`
}

func (q *Queries) ClaimerAdd(ctx context.Context, arg ClaimerAddParams) error {
	_, err := q.db.ExecContext(ctx, claimerAdd, arg.Chid, arg.Router, arg.Evlog)
	return err
}

const claimerGet = `-- name: ClaimerGet :one
SELECT evlog FROM claimer WHERE chid = $1 and router = $2
`

type ClaimerGetParams struct {
	Chid   uint64 `json:"chid"`
	Router string `json:"router"`
}

func (q *Queries) ClaimerGet(ctx context.Context, arg ClaimerGetParams) (binding.ClaimHelpClaimer, error) {
	row := q.db.QueryRowContext(ctx, claimerGet, arg.Chid, arg.Router)
	var evlog binding.ClaimHelpClaimer
	err := row.Scan(&evlog)
	return evlog, err
}

const monGet = `-- name: MonGet :one
SELECT key, blknum, blkidx FROM monitor WHERE key = $1
`

func (q *Queries) MonGet(ctx context.Context, key string) (Monitor, error) {
	row := q.db.QueryRowContext(ctx, monGet, key)
	var i Monitor
	err := row.Scan(&i.Key, &i.Blknum, &i.Blkidx)
	return i, err
}

const monSet = `-- name: MonSet :exec
INSERT INTO monitor (key, blknum, blkidx) VALUES ($1, $2, $3) ON CONFLICT (key) DO UPDATE
SET blknum = excluded.blknum, blkidx = excluded.blkidx
`

type MonSetParams struct {
	Key    string `json:"key"`
	Blknum uint64 `json:"blknum"`
	Blkidx int64  `json:"blkidx"`
}

func (q *Queries) MonSet(ctx context.Context, arg MonSetParams) error {
	_, err := q.db.ExecContext(ctx, monSet, arg.Key, arg.Blknum, arg.Blkidx)
	return err
}

const poolAdd = `-- name: PoolAdd :exec
INSERT INTO pools (chid, poolid, poolkey) VALUES ($1, $2, $3)
`

type PoolAddParams struct {
	Chid    uint64          `json:"chid"`
	Poolid  string          `json:"poolid"`
	Poolkey binding.PoolKey `json:"poolkey"`
}

func (q *Queries) PoolAdd(ctx context.Context, arg PoolAddParams) error {
	_, err := q.db.ExecContext(ctx, poolAdd, arg.Chid, arg.Poolid, arg.Poolkey)
	return err
}

const poolGet = `-- name: PoolGet :one
SELECT poolkey FROM pools WHERE chid = $1 and poolid = $2
`

type PoolGetParams struct {
	Chid   uint64 `json:"chid"`
	Poolid string `json:"poolid"`
}

func (q *Queries) PoolGet(ctx context.Context, arg PoolGetParams) (binding.PoolKey, error) {
	row := q.db.QueryRowContext(ctx, poolGet, arg.Chid, arg.Poolid)
	var poolkey binding.PoolKey
	err := row.Scan(&poolkey)
	return poolkey, err
}

const pools = `-- name: Pools :many
SELECT poolid, poolkey FROM pools WHERE chid = $1
`

type PoolsRow struct {
	Poolid  string          `json:"poolid"`
	Poolkey binding.PoolKey `json:"poolkey"`
}

func (q *Queries) Pools(ctx context.Context, chid uint64) ([]PoolsRow, error) {
	rows, err := q.db.QueryContext(ctx, pools, chid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PoolsRow
	for rows.Next() {
		var i PoolsRow
		if err := rows.Scan(&i.Poolid, &i.Poolkey); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const proofAdd = `-- name: ProofAdd :exec
INSERT INTO proof (reqid, idx, app_prover, app_proof_id, app_circuit_info) VALUES ($1, $2, $3, $4, $5)
`

type ProofAddParams struct {
	Reqid          int64                       `json:"reqid"`
	Idx            int                         `json:"idx"`
	AppProver      string                      `json:"appProver"`
	AppProofID     string                      `json:"appProofId"`
	AppCircuitInfo *commonproto.AppCircuitInfo `json:"appCircuitInfo"`
}

func (q *Queries) ProofAdd(ctx context.Context, arg ProofAddParams) error {
	_, err := q.db.ExecContext(ctx, proofAdd,
		arg.Reqid,
		arg.Idx,
		arg.AppProver,
		arg.AppProofID,
		arg.AppCircuitInfo,
	)
	return err
}

const proofGetIds = `-- name: ProofGetIds :many
SELECT idx, app_proof_id, gateway_batch_id, gateway_request_id, gateway_nonce FROM proof WHERE reqid = $1 ORDER BY idx
`

type ProofGetIdsRow struct {
	Idx              int    `json:"idx"`
	AppProofID       string `json:"appProofId"`
	GatewayBatchID   string `json:"gatewayBatchId"`
	GatewayRequestID string `json:"gatewayRequestId"`
	GatewayNonce     uint64 `json:"gatewayNonce"`
}

func (q *Queries) ProofGetIds(ctx context.Context, reqid int64) ([]ProofGetIdsRow, error) {
	rows, err := q.db.QueryContext(ctx, proofGetIds, reqid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProofGetIdsRow
	for rows.Next() {
		var i ProofGetIdsRow
		if err := rows.Scan(
			&i.Idx,
			&i.AppProofID,
			&i.GatewayBatchID,
			&i.GatewayRequestID,
			&i.GatewayNonce,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const proofSetAppProof = `-- name: ProofSetAppProof :exec
UPDATE proof SET app_proof = $1 and app_circuit_info = $2 WHERE app_proof_id = $3
`

type ProofSetAppProofParams struct {
	AppProof       string                      `json:"appProof"`
	AppCircuitInfo *commonproto.AppCircuitInfo `json:"appCircuitInfo"`
	AppProofID     string                      `json:"appProofId"`
}

func (q *Queries) ProofSetAppProof(ctx context.Context, arg ProofSetAppProofParams) error {
	_, err := q.db.ExecContext(ctx, proofSetAppProof, arg.AppProof, arg.AppCircuitInfo, arg.AppProofID)
	return err
}

const proofSetGwInfo = `-- name: ProofSetGwInfo :exec
UPDATE proof
SET gateway_batch_id = $1,
    gateway_request_id = $2,
    gateway_nonce = $3
WHERE reqid = $4 AND idx = $5
`

type ProofSetGwInfoParams struct {
	GatewayBatchID   string `json:"gatewayBatchId"`
	GatewayRequestID string `json:"gatewayRequestId"`
	GatewayNonce     uint64 `json:"gatewayNonce"`
	Reqid            int64  `json:"reqid"`
	Idx              int    `json:"idx"`
}

func (q *Queries) ProofSetGwInfo(ctx context.Context, arg ProofSetGwInfoParams) error {
	_, err := q.db.ExecContext(ctx, proofSetGwInfo,
		arg.GatewayBatchID,
		arg.GatewayRequestID,
		arg.GatewayNonce,
		arg.Reqid,
		arg.Idx,
	)
	return err
}

const proofSetGwResp = `-- name: ProofSetGwResp :exec
UPDATE proof SET gateway_query_status = $1 WHERE gateway_request_id = $2 AND gateway_nonce = $3
`

type ProofSetGwRespParams struct {
	GatewayQueryStatus *gwproto.GetQueryStatusResponse `json:"gatewayQueryStatus"`
	GatewayRequestID   string                          `json:"gatewayRequestId"`
	GatewayNonce       uint64                          `json:"gatewayNonce"`
}

func (q *Queries) ProofSetGwResp(ctx context.Context, arg ProofSetGwRespParams) error {
	_, err := q.db.ExecContext(ctx, proofSetGwResp, arg.GatewayQueryStatus, arg.GatewayRequestID, arg.GatewayNonce)
	return err
}

const reqAdd = `-- name: ReqAdd :exec
INSERT INTO reqs (id, router, usr_req, proof_info) VALUES ($1, $2, $3, $4)
`

type ReqAddParams struct {
	ID        int64               `json:"id"`
	Router    string              `json:"router"`
	UsrReq    *webapi.NewProofReq `json:"usrReq"`
	ProofInfo binding.ProofInfo   `json:"proofInfo"`
}

func (q *Queries) ReqAdd(ctx context.Context, arg ReqAddParams) error {
	_, err := q.db.ExecContext(ctx, reqAdd,
		arg.ID,
		arg.Router,
		arg.UsrReq,
		arg.ProofInfo,
	)
	return err
}

const reqGetCalldata = `-- name: ReqGetCalldata :one
SELECT calldata FROM reqs WHERE id = $1
`

func (q *Queries) ReqGetCalldata(ctx context.Context, id int64) (binding.CallData, error) {
	row := q.db.QueryRowContext(ctx, reqGetCalldata, id)
	var calldata binding.CallData
	err := row.Scan(&calldata)
	return calldata, err
}
